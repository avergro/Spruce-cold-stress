#' ---
#' title: "Spruce roots cold stress data analysis"
#' author: "Nicolas Delhomme-Alexander Vergara"
#' date: "`r Sys.Date()`"
#' output:
#'  html_document:
#'    toc: true
#'    number_sections: true
#' ---
#' # Setup
#' Set the working dir  
setwd("/mnt/picea/projects/spruce/vhurry/COLD_STRESS/cold-stress-roots")
#' ```{r set up, echo=FALSE}
#' knitr::opts_knit$set(root.dir="/mnt/picea/projects/spruce/vhurry/COLD_STRESS/cold-stress-roots")
#' ```

#' Load libraries
suppressPackageStartupMessages(library(DESeq2))
suppressPackageStartupMessages(library(gplots))
suppressPackageStartupMessages(library(parallel))
suppressPackageStartupMessages(library(pander))
suppressPackageStartupMessages(library(RColorBrewer))
suppressPackageStartupMessages(library(scatterplot3d))
suppressPackageStartupMessages(library(vsn))

#' Source some helper functions
source("~/Git/UPSCb/src/R/plot.multidensity.R")

#' Create a palette
pal <- brewer.pal(8,"Dark2")

#' Register the default plot margin
mar <- par("mar")

#' Read the sample information
samples <- read.csv("~/Git/UPSCb/projects/spruce_cold_stress/spruce-roots-cold-stress/samples2.csv")
head(samples)
samples$ID
#' Create a result dir
system("mkdir ANALYSIS_ROOTS")
outdir <- file.path("ANALYSIS_ROOTS","2017_manuscript_version")
dir.create(outdir,showWarnings=FALSE)


#' Read the HTSeq files in a matrix
res <- mclapply(dir("htseq_technical_replicates",pattern="*.txt",full.names=TRUE),function(fil){
  read.delim(fil,header=FALSE,stringsAsFactors=FALSE)
},mc.cores=max(mcaffinity()))

names(res) <- sub(".*_P1406_","",sub("_sortmerna.*\\.txt","",dir("htseq_technical_replicates",pattern="*.txt")))
                                              
#' Reorder the sample data.frame according to the way
#' the results were read in
samples <- samples[match(names(res),samples$ID),]

#' Raw Data QC analysis
addInfo <- c("__no_feature","__ambiguous","__too_low_aQual","__not_aligned","__alignment_not_unique")
sel <- match(addInfo,res[[1]][,1])
count.table <- do.call(cbind,lapply(res,"[",3))[-sel,]
colnames(count.table) <- names(res)
rownames(count.table) <- res[[1]][,1][-sel]

write.csv(count.table,file.path(outdir,"raw-unormalised-data_27_samples_Roots.csv"))

#' Extract the HTSeq stat lines
count.stats <- do.call(cbind,lapply(res,"[",2))[sel,]
colnames(count.stats) <- names(res)
rownames(count.stats) <- sub("__","",addInfo)
count.stats <- rbind(count.stats,aligned=colSums(count.table))
count.stats <- count.stats[rowSums(count.stats) > 0,]

#' Convert them into percentages
pander(apply(count.stats,2,function(co){round(co*100/sum(co))}))

#' Plot the stats
#' 
#' There are no outliers
col <- pal[1:nrow(count.stats)]
par(mar=c(7.1,5.1,4.1,2.1))
barplot(as.matrix(count.stats),col=col,beside=TRUE,las=2,main="read proportion",
        ylim=range(count.stats) + c(0,4e+6),cex.names=.6)
legend("top",fill=col,legend=gsub("_"," ",rownames(count.stats)),bty="n",cex=0.8)
par(mar=mar)

#' The average percentage of aligned reads is 75%
boxplot(unlist(count.stats["aligned",]/colSums(count.stats)),
        main="aligned reads",ylab="percent aligned",ylim=c(0,1))

#' Check how many genes are never expressed
sel <- rowSums(count.table) == 0
sprintf("%s%% percent (%s) of %s genes are not expressed",
        round(sum(sel) * 100/ nrow(count.table),digits=1),
        sum(sel),
        nrow(count.table))

#' Display the per-gene mean expression
#' 
#' i.e. the mean raw count of every 
#' gene across samples is calculated
#' and displayed on a log10 scale.
#' 
#' The cumulative coverage is as expected, around 100X
plot(density(log10(rowMeans(count.table))),col=pal[1],
     main="mean raw counts distribution",
     xlab="mean raw counts (log10)")

#' 
#' 
head(count.table)
plot.multidensity(log10(count.table),
                  col=pal[as.integer(samples$SampleID)],
                  legend.x="topright",
                  legend=levels(samples$SampleID),
                  legend.col=pal[1:8],
                  legend.lwd=2,
                  main="sample raw counts distribution",
                  xlab="per gene raw counts (log10)")

#' # Data normalisation 
#'  For visualization, the data is
#' submitted to a variance stabilization
#' transformation using DESeq2. The 
#' dispersion is estimated independently
#' of the sample SampleID and replicate

#' Create the dds object
conditions <- colnames(count.table)
dds <- DESeqDataSetFromMatrix(
  countData = count.table,
  colData = data.frame(condition=conditions),
  design = ~ condition)

#' Check the size factors (i.e. the sequencing library size effect)
#' There is no big variation, a Variance Stabilizing Transformation can
#' be used (over a Relative Log Transformation)
dds <- estimateSizeFactors(dds)
sizes <- sizeFactors(dds)
names(sizes) <- colnames(count.table)
sizes
boxplot(sizes, main="Sequencing libraries size factor")

#' Perform the VST
colData(dds)$condition <- factor(colData(dds)$condition,
                                 levels=unique(conditions))
vsd <- varianceStabilizingTransformation(dds, blind=TRUE)
vst <- assay(vsd)
colnames(vst) <- colnames(count.table)

#####Next line must be comment if you really need the real VST values
#vst <- vst - min(vst)  #To print out real VST values we comment this line which was created just to obtain always a zero value for each gene profile 

write.csv(vst,file.path(outdir,"VST_library-size-normalized_data_27_samples_roots.csv"))

#' Validate the VST 
#' 
#' Visualize the corrected mean - sd
#' relationship. It is fairly linear,
#' meaning we can assume homoscedasticity.
#' The slight initial trend / bump is
#' due to genes having few counts in
#' a few subset of the samples and hence 
#' having a higher variability. This is
#' expected.
meanSdPlot(vst[rowSums(count.table)>0,], ylim = c(0,2.5))

#' # QC on the normalised data
#' 
#' #################################################################################
#' ## PCA
#' 
#' First perform a Principal Component
#' Analysis (PCA) of the data
#'  to do a quick quality assessment; 
#' i.e. replicate should cluster
#' and the first 2-3 dimensions should 
#' be explainable by biological means.
pc <- prcomp(t(vst))
percent <- round(summary(pc)$importance[2,]*100)

#' Plot the PCA 3 first dimensions
mar=c(5.1,4.1,4.1,8.1, xpd=TRUE)
#mar – A numeric vector of length 4, which sets the margin sizes in the 
#following order: bottom, left, top, and right. 
#The default is c(5.1, 4.1, 4.1, 2.1).


s3d <- scatterplot3d(pc$x[,1],
                     pc$x[,2],
                     pc$x[,3],
                     xlab=paste("Comp. 1 (",percent[1],"%)",sep=""),
                     ylab=paste("Comp. 2 (",percent[2],"%)",sep=""),
                     zlab=paste("Comp. 3 (",percent[3],"%)",sep=""),
                     color=pal[as.integer(samples$SampleID)],
                     pch=19)

s3d 

legend(3, 4, pch=19,
       col=pal[1:8],
       legend=levels(samples$SampleID))

###########################################
###########################################
# Now we try using a new column od samples object called temperature like sub-population
mar=c(5.1,4.1,4.1,2.1)
popIDs <- unique(samples$Temperature)

# make plot
s3d <- scatterplot3d(pc$x[,1],
                     pc$x[,2],
                     pc$x[,3],
                     xlab=paste("Comp. 1 (",percent[1],"%)",sep=""),
                     ylab=paste("Comp. 2 (",percent[2],"%)",sep=""),
                     zlab=paste("Comp. 3 (",percent[3],"%)",sep=""),
                     color=as.numeric(samples$Temperature),
                     pch=as.numeric(samples$Temperature),
                     y.margin.add=1)
s3d
# add legend 
legend("top", legend = popIDs,
       pch = as.numeric(popIDs), 
       col=as.numeric(popIDs),
       inset = -0.25, xpd = TRUE, horiz = TRUE)
##DONE
# add legend using x, y coordinates to position legend
#legend(6, 6, pch=as.numeric(popIDs), col=as.numeric(popIDs), legend=popIDs)
###########################################
# Now we try using all the labels of sub-populations
head(samples)
popIDs <- unique(samples$SampleID)

s3d <- scatterplot3d(pc$x[,1],
                     pc$x[,2],
                     pc$x[,3],
                     xlab=paste("Comp. 1 (",percent[1],"%)",sep=""),
                     ylab=paste("Comp. 2 (",percent[2],"%)",sep=""),
                     zlab=paste("Comp. 3 (",percent[3],"%)",sep=""),
                     color=as.numeric(samples$SampleID),
                     pch=as.numeric(samples$SampleID),
                     y.margin.add=1)
s3d
# add legend using x, y coordinates to position legend
#legend(6, 6, pch=as.numeric(popIDs), col=as.numeric(popIDs), legend=popIDs)
# add legend
legend(4,5, legend = popIDs,
       pch = as.numeric(popIDs), 
       col=as.numeric(popIDs),
       inset = -0.25, xpd = TRUE, horiz = FALSE)

###########Done
######################################################################################################################
###So we need a mix of both above nomenclatures where shapes represent temperature and colors the time (sampleID)
#We added another colums to samples object called "Sample" . This plot is wrong so try in the future fix that and 
#show temperature with colors and time with shapes instead this way and check of course that all is fine using the 
#previos PCA printed above

#s3d <- scatterplot3d(pc$x[,1],
#                     pc$x[,2],
#                     pc$x[,3],
#                     xlab=paste("Comp. 1 (",percent[1],"%)",sep=""),
#                     ylab=paste("Comp. 2 (",percent[2],"%)",sep=""),
#                     zlab=paste("Comp. 3 (",percent[3],"%)",sep=""),
#                     color=as.numeric(samples$Sample),
#                     pch=as.numeric(samples$Temperature),
#                     y.margin.add=1)
#s3d
## add legend ...HOw can we add 2 legends?
#legend(5, 1,
#       c("freezing", "chillling","control"),
#       cex = 0.8,
#       pch = c(1,2,3))
#par(mar=c(5, 4, 4, 2) + 0.1)
##Now the colours:
#legend(5, 5,
#       c("control", "6h", "24h", "3d", "10d"),
#       col = c("black", "darkgreen", "blue", "brown", "red"),
#       cex = 0.8,
#       lwd = 1, xpd = TRUE)

###########Done
##########################################################################################
##########################################################################################
##########################################################################################
#Now PCA using colours to distigish how deep the dots are in 3D and their names
#NEW
library(plot3D)
pc3 <- cbind(pc$x[,1],pc$x[,2],pc$x[,3])
pcOK<-as.data.frame((pc3))
x <- pcOK$V1
y <- pcOK$V2
z <- pcOK$V3
#text3D(x,y,z,labels = row.names(pc$x), add= TRUE, colkey= FALSE, cex= 0.5)
##new code


#pc3 <- cbind(pc$x[,1],pc$x[,2],pc$x[,3])

#Saving coordinates to add text
pcOK<-as.data.frame((pc3))
x <- pcOK$V1
y <- pcOK$V2
z <- pcOK$V3

#ploting 3D and names
scatter3D(pc$x[,1],
          pc$x[,2],
          pc$x[,3],
          xlab=paste("Comp. 1 (",percent[1],"%)",sep=""),
          ylab=paste("Comp. 2 (",percent[2],"%)",sep=""),
          zlab=paste("Comp. 3 (",percent[3],"%)",sep=""),
          
          pch=19)



text3D(x,y,z,labels = row.names(pc$x), add= TRUE, colkey= FALSE, cex= 0.5)

#######################################################################
#' ## Heatmap
#' The 1000 most variable genes are selected and plotted as a heatmap
dimnames(vst) <- dimnames(count.table)
sel <- order(apply(vst,1,sd),decreasing=TRUE)[1:1000]

#' First with their samples numbers IDs
heatmap.2(vst[sel,],labRow = NA,trace = "none",cexCol = 0.6 )

#######################################################################
#Now we explore the data to filter low expressed genes
#In total we have 70736 gene models
#######################################################################
#The function takes 4 parameters:
#(i) the expression matrix; 
#(ii) a vector of "conditions" matching the columns in the expression matrix;
#e.g. if you have 6 samples, 3 bio rep of "Control" and 3 bio rep of "Fertilised", then the vector will be 
#"Control","Control","Control","Fertilised","Fertilised","Fertilised";
#(iii) an expression cutoff X and 
#(iv) a number of replicates cutoff Y.

#' ## Raw data tissues
#' analyizing raw counts from phase1 (5°C) and and phase2 (-5°C)
#' Keep genes with 2 or more reads in at least 3 replicates
head(samples)
#' In each condition we have 3 reps
#' We considered do not have "outliers" for DE analysis of roots samples
#' We set 3 like the minimum number of biological replicates which must overcome the cutoff
#' 
#' 
#' Function geneSelect to remove low expressed genes:
"geneSelect" <- function(cnt,splt,exp=1,nrep=2){
  rowSums(sapply(lapply(
    split.data.frame(t(cnt >= exp),splt)
    ,colSums), ">=", nrep)) >= 1
}

head(samples)
head(count.table)
dim(count.table)
#sum(sel)
####
#' get the boolean selection
plot(density(log10(as.matrix(count.table)+1))) 
plot(density(log10(as.matrix(count.table))))
sel <- geneSelect(count.table,samples$SampleID,0,0)
#' how many genes are selected
sum(sel)  #no genes removed
class(sel)
head(sel)
plot(density(log10(as.matrix(count.table[sel,]))))

sel <- geneSelect(count.table,samples$SampleID,2,3)
sum(sel)
count.table[sel,]
survivors <- row.names(count.table[sel,])
dim(count.table[sel,])
plot(density(log10(as.matrix(count.table[sel,]))))    #,main="survivors genes counts density"))
#saving survivors genes form roots using 2,3 filter (num min reads, num min of replicates with 2 or more reads)
write.table(survivors, file="Survivors_genes_roots_40092.txt", quote = F, row.names = F, col.names = F)

hpal <- colorRampPalette(c("blue","white","red"))(100)
heatmap.2(as.matrix(count.table[sel,]),scale="row",
          labRow = FALSE,labCol = samples$SampleName,
          trace="none",col=hpal)


#' # Session Info
#' ```{r session info, echo=FALSE}
#'  sessionInfo()
#' ```



